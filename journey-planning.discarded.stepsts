/*
import { Given, When, Then } from '@cucumber/cucumber';
import axios from 'axios';
import assert from 'assert';

//Declare my variables - locations for each scenario, TFL URL, log in credentials, API-KEY etc
//Create the step defintions for each test (GIVEN, WHEN THEN)
//Decide what im going to need to send to query the TFL API endpoint for the Journey API
//(?) Create JSON files if I need to store the API GET calls to send or pass variables
//Connect to TFL URL
//Validate credentials if necessary
//Fetch the data from the endpoints
//Return the data to be the end journey
//Run the tests

// Define the type for a route
interface Route {
  duration: number;
  // Add other properties of the route as needed
}

let startLocation: string = '';
let endLocation: string = '';
let journeyPlan: { journeys: Route[] } | null = null;



const API_KEY = "71820bc06e6941cf9e279e86955f800d";
//ABOVE IS PRIMARY BELOW IS SECONDARY FROM https://api-portal.tfl.gov.uk/profile
//const SECONDARY_API_KEY = "0bd2eba1a8eb4669958c055d04a06742";
//Need to understand which key is used
const BASE_URL = "https://api.tfl.gov.uk";

// Define steps

Given("I am at {string}", function (from: string) {
  startLocation = from;
});

Given("I need to go to {string}", function (to: string) {
  endLocation = to;
});

When("I plan the quickest journey", async function () {
  try {
    // Geocode endpoint
    const geocodeUrl = `${BASE_URL}/Geocode/Search`;

    https://api.tfl.gov.uk/swagger/ui/index.html?url=/swagger/docs/v1#!/Journey/Journey_JourneyResults
    
    // Log the URL for debugging
    console.log('Geocode URL:', geocodeUrl);

    // Search for the start location
    const startResponse = await axios.get(geocodeUrl, {
      params: {
        query: startLocation,
        app_key: API_KEY,
      },
    });

    // Search for the end location
    const endResponse = await axios.get(geocodeUrl, {
      params: {
        query: endLocation,
        app_key: API_KEY,
      },
    });

    // Extract coordinates
    const startMatch = startResponse.data.matches[0];
    const endMatch = endResponse.data.matches[0];
    
    if (!startMatch || !endMatch) {
      throw new Error('Unable to get coordinates for start or end location.');
    }

    const startCoords = `${startMatch.lat},${startMatch.lon}`;
    const endCoords = `${endMatch.lat},${endMatch.lon}`;

    // Journey results endpoint
    const journeyUrl = `${BASE_URL}/Journey/JourneyResults/${startCoords}/to/${endCoords}`;
    
    // Log the URL for debugging
    console.log('Journey URL:', journeyUrl);
    
    const journeyResponse = await axios.get(journeyUrl, {
      params: {
        app_key: API_KEY,
      },
    });

    journeyPlan = journeyResponse.data;
  } catch (error: unknown) {
    if (error instanceof Error) {
      console.error('Error fetching journey plan:', error.message);
    } else {
      console.error('An unknown error occurred');
    }
    throw error;
  }
});


Then("I should see a journey plan with the shortest travel time", function () {
  assert(journeyPlan !== null, 'Journey plan should not be null');
  const routes = journeyPlan.journeys || [];
  assert(routes.length > 0, 'There should be at least one route');

  // Define an initial value for the reduce function
  const initialRoute: Route = { duration: Infinity };

  // Use the initial value in the reduce function
  const shortestRoute = routes.reduce<Route>((prev, curr) =>
    (prev.duration < curr.duration ? prev : curr),
    initialRoute
  );
  
  console.log('Shortest Route:', shortestRoute);
  assert(shortestRoute, 'There should be a route with the shortest duration');
});

/*

//Plan a journey from 69 Notting Hill Gate to Bristol Temple Meads train station
Given(
  "I need to go to {string}",
  function (this: CustomWorld, endLocation: string) {
    this.endLocation = endLocation;
  }
);

When("I plan the journey", async function (this: CustomWorld) {
  const response = await this.tflApi.get(
    `/Journey/JourneyResults/${encodeURIComponent(
      this.startLocation
    )}/to/${encodeURIComponent(this.endLocation)}`
  );
  this.journeyPlan = response.data;
});

Then(
  "I should see a valid journey plan to Bristol Temple Meads",
  function (this: CustomWorld) {
    expect(this.journeyPlan.journeys).to.be.an("array").that.is.not.empty;
    const validJourney = this.journeyPlan.journeys.some((journey) =>
      journey.legs.some((leg) =>
        leg.destinationName.includes("Bristol Temple Meads")
      )
    );
    expect(validJourney).to.be.true;
  }
);

//Plan a journey from Luton Airport to arrive at the office by 8:50 AM next Wednesday

Given(
  "I am arriving at {string}",
  function (this: CustomWorld, startLocation: string) {
    this.startLocation = startLocation;
  }
);

And('I need to arrive at {string} by {string} next Wednesday',
  function (this: CustomWorld, endLocation: string, arrivalTime: string) {
    this.endLocation = endLocation;
    const nextWednesday = moment().day(3).add(1, "weeks").format("YYYY-MM-DD");
    this.arrivalTime = `${nextWednesday}T${arrivalTime}`;
  }
);

When("I plan the latest possible journey", async function (this: CustomWorld) {
  const response = await this.tflApi.get(
    `/Journey/JourneyResults/${encodeURIComponent(
      this.startLocation
    )}/to/${encodeURIComponent(this.endLocation)}?date=${
      this.arrivalTime
    }&timeIs=arriving`
  );
  this.journeyPlan = response.data;
});

Then(
  "I should see a journey that arrives before {string} on that day",
  function (this: CustomWorld, time: string) {
    const arrivalDateTime = moment(this.arrivalTime);
    expect(this.journeyPlan.journeys).to.be.an("array").that.is.not.empty;
    const validJourney = this.journeyPlan.journeys.some((journey) => {
      const arrivalTime = moment(journey.arrivalDateTime);
      return arrivalTime.isSameOrBefore(arrivalDateTime);
    });
    expect(validJourney).to.be.true;
  }

 
);

 */
